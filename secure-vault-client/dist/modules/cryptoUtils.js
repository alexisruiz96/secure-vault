import * as scryptPbkdf from 'scrypt-pbkdf';
import * as base64 from '@juanelas/base64';
export class CryptoUtil {
    constructor(options) {
        this._subtleCrypto = window.crypto.subtle;
        this._options = options;
    }
    /**
     * Generate key using KDF with scrypt
     * @param {string} password introduced password by user
     * @param {boolean} base64Format if true, the key will be returned in base64 format
     * @returns {ArrayBuffer} generated key
     */
    //TODO pass keyLength as parameter
    async generateKey(password, base64Format) {
        const salt = await this.generateFixedSalt(password);
        const derivedKeyLength = 32; // in bytes
        const key = await scryptPbkdf.scrypt(password, salt, derivedKeyLength); // key is an ArrayBuffer
        if (base64Format) {
            return this.convertBufferToBase64(key);
        }
        return key;
    }
    /**
     * Generate fixed salt, it has to be the same to check the key later
     * @param {string} password password introduced by user
     * @returns
     */
    //TODO: pass algorithm as parameter
    async generateFixedSalt(password) {
        const hash = (await this.generatePasswordHash(password, "SHA-256", false));
        return hash.slice(16);
    }
    /**
     * Generate fixed salt, it has to be the same to check the key later
     * @param {string} password password introduced by user
     * @param {string} algorithm used to generate the hash
     * @param {boolean} base64Format indicates if the output is in base64 format
     * @returns
     */
    //TODO: pass algorithm and if return value in base64 or ArrayBuffer
    async generatePasswordHash(password, algorithm, base64Format) {
        const encoder = new TextEncoder();
        const data = encoder.encode(password);
        const hash = await this._subtleCrypto.digest(algorithm, data);
        if (base64Format) {
            return this.convertBufferToBase64(hash);
        }
        return hash;
    }
    /**
     * Generate CryptoKey object with SubtleCrypto
     * @param {string} keyData Key passed as string encoded with base64
     * @returns {string} CryptoKey object stringified
     */
    //TODO: pass keyusage as param
    //TODO: pass algorithm as param
    //TODO: pass extractable as param
    async generateCryptoKey(keyData) {
        let keyDataDecoded = this.convertBase64ToBuffer(keyData);
        let cryptoKey;
        let actions = ["encrypt", "decrypt"];
        if (typeof keyDataDecoded === "string") {
            keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
        }
        let jsonWebKey = "";
        try {
            cryptoKey = await this._subtleCrypto.importKey(this._options.format, keyDataDecoded, {
                name: this._options.algorithm,
            }, true, actions);
            const exportedKey = await this._subtleCrypto.exportKey("jwk", cryptoKey);
            jsonWebKey = JSON.stringify(exportedKey);
            //console.log(cryptoKeyGlobal)
        }
        catch (error) {
            console.error("Error generating CryptoKey: " + error);
        }
        return jsonWebKey;
    }
    /**
     * Encrypt data passing cryptoKey and data
     * @param {string} cryptoKeyJwk
     * @returns {JSON} Returns IV and data encrypted
     */
    //TODO: pass algorithm as param
    //TODO: pass cryptoKey as string or ArrayBuffer
    async encryptData(data) {
        const cryptoKey = await this.convertJwkToCryptoKey(this._encCryptoKey, this._options.algorithm);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        let ciphertext;
        try {
            ciphertext = await this._subtleCrypto.encrypt({
                name: this._options.algorithm,
                iv,
            }, cryptoKey, data);
            //TODO Check to return data as ArrayBuffer
            //TODO epochtime
            const base64IV = this.convertBufferToBase64(iv);
            const base64Data = this.convertBufferToBase64(ciphertext);
            const encryptedObject = {
                base64IV,
                base64Data,
            };
            return this.formatEncryptedData(encryptedObject);
        }
        catch (error) {
            console.error("Error encrypting data: " + error);
        }
    }
    /**
     * Pass JsonWebKey to CryptoKey and decrypt data
     * @param {string} userCryptoKey JsonWebKey stringified
     * @param {ArrayBuffer} encryptedData Encrypted binary data
     * @param {string} dataIV used to encrypt data
     */
    //TODO: pass algorithm as param
    async decryptData(encryptedData, dataIV) {
        const cryptoKey = await this.convertJwkToCryptoKey(this._encCryptoKey, this._options.algorithm);
        const iv = this.convertBase64ToBuffer(dataIV);
        if (iv instanceof Uint8Array && encryptedData instanceof Uint8Array) {
            try {
                return await this._subtleCrypto.decrypt({
                    name: "AES-GCM",
                    iv: iv,
                }, cryptoKey, encryptedData);
            }
            catch (error) {
                let errorMessage = "Failed authentication.";
                if (error instanceof Error) {
                    if (error.toString() === "Error: Cipher job failed") {
                        console.error("Error: Wrong password!!!");
                    }
                    else {
                        console.error("Error decrypting data: " + error);
                    }
                }
                console.log(errorMessage);
            }
        }
        else {
            console.error("Error datatype during IV and Cipher processing.");
        }
    }
    async downloadDataFromUrl(downloadUrl) {
        const cryptoUtil = this;
        const res = await fetch(downloadUrl, {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        })
            .then((response) => {
            return response.body;
        })
            .then((rb) => {
            if (rb === null)
                throw new Error("Response body is null");
            const reader = rb.getReader();
            return new ReadableStream({
                start(controller) {
                    // The following function handles each data chunk
                    const push = () => {
                        // "done" is a Boolean and value a "Uint8Array"
                        reader.read().then(async ({ done, value }) => {
                            // If there is no more data to read
                            if (done) {
                                console.log("done", done);
                                controller.close();
                                return;
                            }
                            // Get the data and send it to the browser via the controller
                            controller.enqueue(value);
                            // Check chunks by logging to the console
                            console.log(done, value);
                            push();
                        });
                    };
                    push();
                },
            });
        })
            .then((stream) => 
        // Respond with our stream
        stream
            .getReader()
            .read()
            .then(({ value }) => {
            localStorage.setItem("vault_data", cryptoUtil.convertBufferToBase64(value));
        }))
            .then((result) => {
            // Do things with result
            console.log(result);
        })
            .catch((e) => console.error(e.message));
        // console.log(res);
    }
    async downloadDataFromLocalStorage(saltData) {
        try {
            if (localStorage.getItem("vault_data_type") === null)
                throw Error;
            const decoder = new TextDecoder();
            const encodedType = this.convertBase64ToBuffer(localStorage.getItem("vault_data_type"));
            const vault_type = decoder.decode(encodedType);
            const vault_data = this.convertBase64ToBuffer(localStorage.getItem("vault_data"));
            const decryptedData = await this.decryptData(vault_data, saltData);
            const randomName = this.convertBufferToBase64(crypto.getRandomValues(new Uint8Array(12)));
            //TODO check file extension
            if (decryptedData === undefined)
                throw Error;
            const blob = new Blob([decryptedData], { type: vault_type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = randomName;
            document.body.appendChild(a); // we need to append the element to the dom -> otherwise it will not work in firefox
            a.click();
            a.remove();
        }
        catch (error) {
            console.error("Error downloading data from local storage");
        }
    }
    convertBufferToBase64(data) {
        return base64.encode(data, true, false);
    }
    convertBase64ToBuffer(data) {
        return base64.decode(data);
    }
    /**
     * Import CryptoKey in jwk format
     * format, keyData, algorithm, extractable, keyUsages
     * @param {string} jwk JSON Web Key
     * @param {string} algorithm
     */
    async convertJwkToCryptoKey(jwk, algorithm) {
        const jwkParsed = JSON.parse(jwk);
        let keyDataDecoded = this.convertBase64ToBuffer(jwkParsed.k);
        if (typeof keyDataDecoded === "string") {
            keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
        }
        return this._subtleCrypto.importKey("raw", keyDataDecoded, {
            name: algorithm,
        }, jwkParsed.ext, jwkParsed.key_ops);
    }
    formatEncryptedData(encryptedObject) {
        const data = [];
        data.push({
            iv: encryptedObject.base64IV,
            encryptedData: encryptedObject.base64Data,
        });
        return JSON.stringify(data);
    }
    //GETTERS & SETTERS
    get encCryptoKey() {
        return this._encCryptoKey;
    }
    set encCryptoKey(value) {
        this._encCryptoKey = value;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvVXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbW9kdWxlcy9jcnlwdG9VdGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssV0FBVyxNQUFNLGNBQWMsQ0FBQztBQUU1QyxPQUFPLEtBQUssTUFBTSxNQUFNLGtCQUFrQixDQUFDO0FBUzNDLE1BQU0sT0FBTyxVQUFVO0lBS25CLFlBQVksT0FBdUI7UUFGMUIsa0JBQWEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUcxQyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxrQ0FBa0M7SUFDbEMsS0FBSyxDQUFDLFdBQVcsQ0FDYixRQUFnQixFQUNoQixZQUFxQjtRQUVyQixNQUFNLElBQUksR0FBZ0IsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDakUsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsQ0FBQyxXQUFXO1FBQ3hDLE1BQU0sR0FBRyxHQUFHLE1BQU0sV0FBVyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFFaEcsSUFBSSxZQUFZLEVBQUU7WUFDZCxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxQztRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxtQ0FBbUM7SUFDbkMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLFFBQWdCO1FBQ3BDLE1BQU0sSUFBSSxHQUFnQixDQUFDLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUN0RCxRQUFRLEVBQ1IsU0FBUyxFQUNULEtBQUssQ0FDUixDQUEyQixDQUFDO1FBQzdCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMs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c0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc2NyeXB0UGJrZGYgZnJvbSAnc2NyeXB0LXBia2RmJztcblxuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJ0BqdWFuZWxhcy9iYXNlNjQnO1xuXG5pbXBvcnQgeyBJQ3J5cHRvT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW50ZXJmYWNlcyc7XG5cbmludGVyZmFjZSBFbmNyeXB0ZWREYXRhIHtcbiAgICBiYXNlNjRJVjogc3RyaW5nO1xuICAgIGJhc2U2NERhdGE6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIENyeXB0b1V0aWwge1xuICAgIHByaXZhdGUgX29wdGlvbnM6IElDcnlwdG9PcHRpb25zO1xuICAgIHByaXZhdGUgX2VuY0NyeXB0b0tleT86IHN0cmluZztcbiAgICByZWFkb25seSBfc3VidGxlQ3J5cHRvID0gd2luZG93LmNyeXB0by5zdWJ0bGU7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBJQ3J5cHRvT3B0aW9ucykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBrZXkgdXNpbmcgS0RGIHdpdGggc2NyeXB0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIGludHJvZHVjZWQgcGFzc3dvcmQgYnkgdXNlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFzZTY0Rm9ybWF0IGlmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZXR1cm5lZCBpbiBiYXNlNjQgZm9ybWF0XG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBnZW5lcmF0ZWQga2V5XG4gICAgICovXG4gICAgLy9UT0RPIHBhc3Mga2V5TGVuZ3RoIGFzIHBhcmFtZXRlclxuICAgIGFzeW5jIGdlbmVyYXRlS2V5KFxuICAgICAgICBwYXNzd29yZDogc3RyaW5nLFxuICAgICAgICBiYXNlNjRGb3JtYXQ6IGJvb2xlYW5cbiAgICApOiBQcm9taXNlPHN0cmluZyB8IEFycmF5QnVmZmVyPiB7XG4gICAgICAgIGNvbnN0IHNhbHQ6IEFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUZpeGVkU2FsdChwYXNzd29yZCk7XG4gICAgICAgIGNvbnN0IGRlcml2ZWRLZXlMZW5ndGggPSAzMjsgLy8gaW4gYnl0ZXNcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgc2NyeXB0UGJrZGYuc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBkZXJpdmVkS2V5TGVuZ3RoKTsgLy8ga2V5IGlzIGFuIEFycmF5QnVmZmVyXG5cbiAgICAgICAgaWYgKGJhc2U2NEZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEJ1ZmZlclRvQmFzZTY0KGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGZpeGVkIHNhbHQsIGl0IGhhcyB0byBiZSB0aGUgc2FtZSB0byBjaGVjayB0aGUga2V5IGxhdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIHBhc3N3b3JkIGludHJvZHVjZWQgYnkgdXNlclxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbWV0ZXJcbiAgICBhc3luYyBnZW5lcmF0ZUZpeGVkU2FsdChwYXNzd29yZDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGhhc2g6IEFycmF5QnVmZmVyID0gKGF3YWl0IHRoaXMuZ2VuZXJhdGVQYXNzd29yZEhhc2goXG4gICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgIFwiU0hBLTI1NlwiLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKSkgYXMgdW5rbm93biBhcyBBcnJheUJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIGhhc2guc2xpY2UoMTYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGZpeGVkIHNhbHQsIGl0IGhhcyB0byBiZSB0aGUgc2FtZSB0byBjaGVjayB0aGUga2V5IGxhdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIHBhc3N3b3JkIGludHJvZHVjZWQgYnkgdXNlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGdvcml0aG0gdXNlZCB0byBnZW5lcmF0ZSB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFzZTY0Rm9ybWF0IGluZGljYXRlcyBpZiB0aGUgb3V0cHV0IGlzIGluIGJhc2U2NCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIC8vVE9ETzogcGFzcyBhbGdvcml0aG0gYW5kIGlmIHJldHVybiB2YWx1ZSBpbiBiYXNlNjQgb3IgQXJyYXlCdWZmZXJcbiAgICBhc3luYyBnZW5lcmF0ZVBhc3N3b3JkSGFzaChcbiAgICAgICAgcGFzc3dvcmQ6IHN0cmluZyxcbiAgICAgICAgYWxnb3JpdGhtOiBzdHJpbmcsXG4gICAgICAgIGJhc2U2NEZvcm1hdDogYm9vbGVhblxuICAgICk6IFByb21pc2U8c3RyaW5nIHwgQXJyYXlCdWZmZXI+IHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUocGFzc3dvcmQpO1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xuICAgICAgICBpZiAoYmFzZTY0Rm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QnVmZmVyVG9CYXNlNjQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgQ3J5cHRvS2V5IG9iamVjdCB3aXRoIFN1YnRsZUNyeXB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlEYXRhIEtleSBwYXNzZWQgYXMgc3RyaW5nIGVuY29kZWQgd2l0aCBiYXNlNjRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDcnlwdG9LZXkgb2JqZWN0IHN0cmluZ2lmaWVkXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGtleXVzYWdlIGFzIHBhcmFtXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbVxuICAgIC8vVE9ETzogcGFzcyBleHRyYWN0YWJsZSBhcyBwYXJhbVxuICAgIGFzeW5jIGdlbmVyYXRlQ3J5cHRvS2V5KGtleURhdGE6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGxldCBrZXlEYXRhRGVjb2RlZDogc3RyaW5nIHwgVWludDhBcnJheSA9XG4gICAgICAgICAgICB0aGlzLmNvbnZlcnRCYXNlNjRUb0J1ZmZlcihrZXlEYXRhKTtcbiAgICAgICAgbGV0IGNyeXB0b0tleTogQ3J5cHRvS2V5O1xuICAgICAgICBsZXQgYWN0aW9uczogS2V5VXNhZ2VbXSA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCJdO1xuICAgICAgICBpZiAodHlwZW9mIGtleURhdGFEZWNvZGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXlEYXRhRGVjb2RlZCA9IEJ1ZmZlci5mcm9tKGtleURhdGFEZWNvZGVkLCBcInV0Zi04XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqc29uV2ViS2V5OiBzdHJpbmcgPSBcIlwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmltcG9ydEtleShcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgICAgICBrZXlEYXRhRGVjb2RlZCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX29wdGlvbnMuYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRLZXk6IEpzb25XZWJLZXkgPSBhd2FpdCB0aGlzLl9zdWJ0bGVDcnlwdG8uZXhwb3J0S2V5KFxuICAgICAgICAgICAgICAgIFwiandrXCIsXG4gICAgICAgICAgICAgICAgY3J5cHRvS2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAganNvbldlYktleSA9IEpTT04uc3RyaW5naWZ5KGV4cG9ydGVkS2V5KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY3J5cHRvS2V5R2xvYmFsKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgQ3J5cHRvS2V5OiBcIiArIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbldlYktleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNyeXB0IGRhdGEgcGFzc2luZyBjcnlwdG9LZXkgYW5kIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3J5cHRvS2V5SndrXG4gICAgICogQHJldHVybnMge0pTT059IFJldHVybnMgSVYgYW5kIGRhdGEgZW5jcnlwdGVkXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbVxuICAgIC8vVE9ETzogcGFzcyBjcnlwdG9LZXkgYXMgc3RyaW5nIG9yIEFycmF5QnVmZmVyXG4gICAgYXN5bmMgZW5jcnlwdERhdGEoZGF0YTogQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5jb252ZXJ0SndrVG9DcnlwdG9LZXkoXG4gICAgICAgICAgICB0aGlzLl9lbmNDcnlwdG9LZXkgYXMgc3RyaW5nLFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hbGdvcml0aG1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBpdiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKTtcbiAgICAgICAgbGV0IGNpcGhlcnRleHQ6IEFycmF5QnVmZmVyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmVuY3J5cHQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9vcHRpb25zLmFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICAgICAgaXYsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcnlwdG9LZXksXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy9UT0RPIENoZWNrIHRvIHJldHVybiBkYXRhIGFzIEFycmF5QnVmZmVyXG4gICAgICAgICAgICAvL1RPRE8gZXBvY2h0aW1lXG4gICAgICAgICAgICBjb25zdCBiYXNlNjRJViA9IHRoaXMuY29udmVydEJ1ZmZlclRvQmFzZTY0KGl2KTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSB0aGlzLmNvbnZlcnRCdWZmZXJUb0Jhc2U2NChjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICBiYXNlNjRJVixcbiAgICAgICAgICAgICAgICBiYXNlNjREYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdEVuY3J5cHRlZERhdGEoZW5jcnlwdGVkT2JqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBlbmNyeXB0aW5nIGRhdGE6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzcyBKc29uV2ViS2V5IHRvIENyeXB0b0tleSBhbmQgZGVjcnlwdCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJDcnlwdG9LZXkgSnNvbldlYktleSBzdHJpbmdpZmllZFxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGVuY3J5cHRlZERhdGEgRW5jcnlwdGVkIGJpbmFyeSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFJViB1c2VkIHRvIGVuY3J5cHQgZGF0YVxuICAgICAqL1xuICAgIC8vVE9ETzogcGFzcyBhbGdvcml0aG0gYXMgcGFyYW1cbiAgICBhc3luYyBkZWNyeXB0RGF0YShlbmNyeXB0ZWREYXRhOiBBcnJheUJ1ZmZlciwgZGF0YUlWOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5jb252ZXJ0SndrVG9DcnlwdG9LZXkoXG4gICAgICAgICAgICB0aGlzLl9lbmNDcnlwdG9LZXkgYXMgc3RyaW5nLFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hbGdvcml0aG1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXYgPSB0aGlzLmNvbnZlcnRCYXNlNjRUb0J1ZmZlcihkYXRhSVYpIGFzIFVpbnQ4QXJyYXk7XG5cbiAgICAgICAgaWYgKGl2IGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBlbmNyeXB0ZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmRlY3J5cHQoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQUVTLUdDTVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjcnlwdG9LZXksXG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZERhdGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJGYWlsZWQgYXV0aGVudGljYXRpb24uXCI7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRvU3RyaW5nKCkgPT09IFwiRXJyb3I6IENpcGhlciBqb2IgZmFpbGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvcjogV3JvbmcgcGFzc3dvcmQhISFcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjcnlwdGluZyBkYXRhOiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRhdGF0eXBlIGR1cmluZyBJViBhbmQgQ2lwaGVyIHByb2Nlc3NpbmcuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZG93bmxvYWREYXRhRnJvbVVybChkb3dubG9hZFVybDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNyeXB0b1V0aWwgPSB0aGlzO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChkb3dubG9hZFVybCBhcyBzdHJpbmcsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCI6IFwiKlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyYikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2UgYm9keSBpcyBudWxsXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJiLmdldFJlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaGFuZGxlcyBlYWNoIGRhdGEgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1c2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJkb25lXCIgaXMgYSBCb29sZWFuIGFuZCB2YWx1ZSBhIFwiVWludDhBcnJheVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGFzeW5jICh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbW9yZSBkYXRhIHRvIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZG9uZVwiLCBkb25lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSBhbmQgc2VuZCBpdCB0byB0aGUgYnJvd3NlciB2aWEgdGhlIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgY2h1bmtzIGJ5IGxvZ2dpbmcgdG8gdGhlIGNvbnNvbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZG9uZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHN0cmVhbSkgPT5cbiAgICAgICAgICAgICAgICAvLyBSZXNwb25kIHdpdGggb3VyIHN0cmVhbVxuICAgICAgICAgICAgICAgIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAuZ2V0UmVhZGVyKClcbiAgICAgICAgICAgICAgICAgICAgLnJlYWQoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInZhdWx0X2RhdGFcIiwgY3J5cHRvVXRpbC5jb252ZXJ0QnVmZmVyVG9CYXNlNjQodmFsdWUgYXMgQXJyYXlCdWZmZXIpKTsgIFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIERvIHRoaW5ncyB3aXRoIHJlc3VsdFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiBjb25zb2xlLmVycm9yKGUubWVzc2FnZSkpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhyZXMpO1xuICAgIH1cblxuICAgIGFzeW5jIGRvd25sb2FkRGF0YUZyb21Mb2NhbFN0b3JhZ2Uoc2FsdERhdGE6IHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidmF1bHRfZGF0YV90eXBlXCIpID09PSBudWxsKSB0aHJvdyBFcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gdGhpcy5jb252ZXJ0QmFzZTY0VG9CdWZmZXIoXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ2YXVsdF9kYXRhX3R5cGVcIikgYXMgc3RyaW5nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgdmF1bHRfdHlwZSA9IGRlY29kZXIuZGVjb2RlKGVuY29kZWRUeXBlIGFzIFVpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgY29uc3QgdmF1bHRfZGF0YSA9IHRoaXMuY29udmVydEJhc2U2NFRvQnVmZmVyKFxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidmF1bHRfZGF0YVwiKSBhcyBzdHJpbmdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBhd2FpdCB0aGlzLmRlY3J5cHREYXRhKFxuICAgICAgICAgICAgICAgIHZhdWx0X2RhdGEgYXMgQXJyYXlCdWZmZXIsXG4gICAgICAgICAgICAgICAgc2FsdERhdGFcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbU5hbWUgPSB0aGlzLmNvbnZlcnRCdWZmZXJUb0Jhc2U2NChcbiAgICAgICAgICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL1RPRE8gY2hlY2sgZmlsZSBleHRlbnNpb25cbiAgICAgICAgICAgIGlmIChkZWNyeXB0ZWREYXRhID09PSB1bmRlZmluZWQpIHRocm93IEVycm9yO1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtkZWNyeXB0ZWREYXRhXSwgeyB0eXBlOiB2YXVsdF90eXBlIH0pO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgICAgICAgIGEuZG93bmxvYWQgPSByYW5kb21OYW1lO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTsgLy8gd2UgbmVlZCB0byBhcHBlbmQgdGhlIGVsZW1lbnQgdG8gdGhlIGRvbSAtPiBvdGhlcndpc2UgaXQgd2lsbCBub3Qgd29yayBpbiBmaXJlZm94XG4gICAgICAgICAgICBhLmNsaWNrKCk7XG4gICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRvd25sb2FkaW5nIGRhdGEgZnJvbSBsb2NhbCBzdG9yYWdlXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29udmVydEJ1ZmZlclRvQmFzZTY0KGRhdGE6IEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQuZW5jb2RlKGRhdGEsIHRydWUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb252ZXJ0QmFzZTY0VG9CdWZmZXIoZGF0YTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcG9ydCBDcnlwdG9LZXkgaW4gandrIGZvcm1hdFxuICAgICAqIGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGp3ayBKU09OIFdlYiBLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxnb3JpdGhtXG4gICAgICovXG4gICAgYXN5bmMgY29udmVydEp3a1RvQ3J5cHRvS2V5KGp3azogc3RyaW5nLCBhbGdvcml0aG06IHN0cmluZykge1xuICAgICAgICBjb25zdCBqd2tQYXJzZWQ6IEpzb25XZWJLZXkgPSBKU09OLnBhcnNlKGp3ayk7XG4gICAgICAgIGxldCBrZXlEYXRhRGVjb2RlZCA9IHRoaXMuY29udmVydEJhc2U2NFRvQnVmZmVyKGp3a1BhcnNlZC5rISk7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5RGF0YURlY29kZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleURhdGFEZWNvZGVkID0gQnVmZmVyLmZyb20oa2V5RGF0YURlY29kZWQsIFwidXRmLThcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnRsZUNyeXB0by5pbXBvcnRLZXkoXG4gICAgICAgICAgICBcInJhd1wiLFxuICAgICAgICAgICAga2V5RGF0YURlY29kZWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogYWxnb3JpdGhtLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGp3a1BhcnNlZC5leHQhLFxuICAgICAgICAgICAgandrUGFyc2VkLmtleV9vcHMgYXMgS2V5VXNhZ2VbXVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZvcm1hdEVuY3J5cHRlZERhdGEoZW5jcnlwdGVkT2JqZWN0OiBFbmNyeXB0ZWREYXRhKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGl2OiBlbmNyeXB0ZWRPYmplY3QuYmFzZTY0SVYsXG4gICAgICAgICAgICBlbmNyeXB0ZWREYXRhOiBlbmNyeXB0ZWRPYmplY3QuYmFzZTY0RGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG5cbiAgICAvL0dFVFRFUlMgJiBTRVRURVJTXG4gICAgcHVibGljIGdldCBlbmNDcnlwdG9LZXkoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY0NyeXB0b0tleTtcbiAgICB9XG4gICAgcHVibGljIHNldCBlbmNDcnlwdG9LZXkodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9lbmNDcnlwdG9LZXkgPSB2YWx1ZTtcbiAgICB9XG59XG4iXX0=