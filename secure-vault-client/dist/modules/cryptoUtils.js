import * as scryptPbkdf from 'scrypt-pbkdf';
import * as base64 from '@juanelas/base64';
export class CryptoUtil {
    constructor(options) {
        this._subtleCrypto = window.crypto.subtle;
        this._options = options;
    }
    /**
     * Generate key using KDF with scrypt
     * @param {string} password introduced password by user
     * @param {boolean} base64Format if true, the key will be returned in base64 format
     * @returns {ArrayBuffer} generated key
     */
    //TODO pass keyLength as parameter
    async generateKey(password, base64Format) {
        const salt = await this.generateFixedSalt(password);
        const derivedKeyLength = 32; // in bytes
        const key = await scryptPbkdf.scrypt(password, salt, derivedKeyLength); // key is an ArrayBuffer
        if (base64Format) {
            return this.convertBufferToBase64(key);
        }
        return key;
    }
    /**
     * Generate fixed salt, it has to be the same to check the key later
     * @param {string} password password introduced by user
     * @returns
     */
    //TODO: pass algorithm as parameter
    async generateFixedSalt(password) {
        const hash = (await this.generatePasswordHash(password, "SHA-256", false));
        return hash.slice(16);
    }
    /**
     * Generate fixed salt, it has to be the same to check the key later
     * @param {string} password password introduced by user
     * @param {string} algorithm used to generate the hash
     * @param {boolean} base64Format indicates if the output is in base64 format
     * @returns
     */
    //TODO: pass algorithm and if return value in base64 or ArrayBuffer
    async generatePasswordHash(password, algorithm, base64Format) {
        const encoder = new TextEncoder();
        const data = encoder.encode(password);
        const hash = await this._subtleCrypto.digest(algorithm, data);
        if (base64Format) {
            return this.convertBufferToBase64(hash);
        }
        return hash;
    }
    /**
     * Generate CryptoKey object with SubtleCrypto
     * @param {string} keyData Key passed as string encoded with base64
     * @returns {string} CryptoKey object stringified
     */
    //TODO: pass keyusage as param
    //TODO: pass algorithm as param
    //TODO: pass extractable as param
    async generateCryptoKey(keyData) {
        let keyDataDecoded = this.convertBase64ToBuffer(keyData);
        let cryptoKey;
        let actions = ["encrypt", "decrypt"];
        if (typeof keyDataDecoded === "string") {
            keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
        }
        let jsonWebKey = "";
        try {
            cryptoKey = await this._subtleCrypto.importKey(this._options.format, keyDataDecoded, {
                name: this._options.algorithm,
            }, true, actions);
            const exportedKey = await this._subtleCrypto.exportKey("jwk", cryptoKey);
            jsonWebKey = JSON.stringify(exportedKey);
            //console.log(cryptoKeyGlobal)
        }
        catch (error) {
            console.error("Error generating CryptoKey: " + error);
        }
        return jsonWebKey;
    }
    /**
     * Encrypt data passing cryptoKey and data
     * @param {string} cryptoKeyJwk
     * @returns {JSON} Returns IV and data encrypted
     */
    //TODO: pass algorithm as param
    //TODO: pass cryptoKey as string or ArrayBuffer
    async encryptData(data) {
        const cryptoKey = await this.convertJwkToCryptoKey(this._encCryptoKey, this._options.algorithm);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        let ciphertext;
        try {
            ciphertext = await this._subtleCrypto.encrypt({
                name: this._options.algorithm,
                iv,
            }, cryptoKey, data);
            //TODO Check to return data as ArrayBuffer
            //TODO epochtime
            const base64IV = this.convertBufferToBase64(iv);
            const base64Data = this.convertBufferToBase64(ciphertext);
            const encryptedObject = {
                base64IV,
                base64Data,
            };
            return this.formatEncryptedData(encryptedObject);
        }
        catch (error) {
            console.error("Error encrypting data: " + error);
        }
    }
    /**
     * Pass JsonWebKey to CryptoKey and decrypt data
     * @param {string} userCryptoKey JsonWebKey stringified
     * @param {ArrayBuffer} encryptedData Encrypted binary data
     * @param {string} dataIV used to encrypt data
     */
    //TODO: pass algorithm as param
    async decryptData(encryptedData, dataIV) {
        const cryptoKey = await this.convertJwkToCryptoKey(this._encCryptoKey, this._options.algorithm);
        const iv = this.convertBase64ToBuffer(dataIV);
        if (iv instanceof Uint8Array && encryptedData instanceof Uint8Array) {
            try {
                return await this._subtleCrypto.decrypt({
                    name: "AES-GCM",
                    iv: iv,
                }, cryptoKey, encryptedData);
            }
            catch (error) {
                debugger;
                let errorMessage = "Failed authentication.";
                if (error instanceof Error) {
                    if (error.toString() === "Error: Cipher job failed") {
                        console.error("Error: Wrong password!!!");
                    }
                    else {
                        console.error("Error decrypting data: " + error);
                    }
                }
                console.log(errorMessage);
            }
        }
        else {
            console.error("Error datatype during IV and Cipher processing.");
        }
    }
    convertBufferToBase64(data) {
        return base64.encode(data, true, false);
    }
    convertBase64ToBuffer(data) {
        return base64.decode(data);
    }
    /**
     * Import CryptoKey in jwk format
     * format, keyData, algorithm, extractable, keyUsages
     * @param {string} jwk JSON Web Key
     * @param {string} algorithm
     */
    async convertJwkToCryptoKey(jwk, algorithm) {
        const jwkParsed = JSON.parse(jwk);
        let keyDataDecoded = this.convertBase64ToBuffer(jwkParsed.k);
        if (typeof keyDataDecoded === "string") {
            keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
        }
        return this._subtleCrypto.importKey("raw", keyDataDecoded, {
            name: algorithm,
        }, jwkParsed.ext, jwkParsed.key_ops);
    }
    formatEncryptedData(encryptedObject) {
        const data = [];
        data.push({
            iv: encryptedObject.base64IV,
            encryptedData: encryptedObject.base64Data,
        });
        return JSON.stringify(data);
    }
    //GETTERS & SETTERS
    get encCryptoKey() {
        return this._encCryptoKey;
    }
    set encCryptoKey(value) {
        this._encCryptoKey = value;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvVXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbW9kdWxlcy9jcnlwdG9VdGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssV0FBVyxNQUFNLGNBQWMsQ0FBQztBQUU1QyxPQUFPLEtBQUssTUFBTSxNQUFNLGtCQUFrQixDQUFDO0FBUzNDLE1BQU0sT0FBTyxVQUFVO0lBS25CLFlBQVksT0FBdUI7UUFGMUIsa0JBQWEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUcxQyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxrQ0FBa0M7SUFDbEMsS0FBSyxDQUFDLFdBQVcsQ0FDYixRQUFnQixFQUNoQixZQUFxQjtRQUVyQixNQUFNLElBQUksR0FBZ0IsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDakUsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsQ0FBQyxXQUFXO1FBQ3hDLE1BQU0sR0FBRyxHQUFHLE1BQU0sV0FBVyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFFaEcsSUFBSSxZQUFZLEVBQUU7WUFDZCxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxQztRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxtQ0FBbUM7SUFDbkMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLFFBQWdCO1FBQ3BDLE1BQU0sSUFBSSxHQUFnQixDQUFDLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUN0RCxRQUFRLEVBQ1IsU0FBUyxFQUNULEtBQUssQ0FDUixDQUEyQixDQUFDO1FBQzdCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMs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Q25CLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUM5QixDQUFDO0lBQ0QsSUFBVyxZQUFZLENBQUMsS0FBeUI7UUFDN0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7SUFDL0IsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc2NyeXB0UGJrZGYgZnJvbSAnc2NyeXB0LXBia2RmJztcblxuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJ0BqdWFuZWxhcy9iYXNlNjQnO1xuXG5pbXBvcnQgeyBJQ3J5cHRvT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW50ZXJmYWNlcyc7XG5cbmludGVyZmFjZSBFbmNyeXB0ZWREYXRhIHtcbiAgICBiYXNlNjRJVjogc3RyaW5nO1xuICAgIGJhc2U2NERhdGE6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIENyeXB0b1V0aWwge1xuICAgIHByaXZhdGUgX29wdGlvbnM6IElDcnlwdG9PcHRpb25zO1xuICAgIHByaXZhdGUgX2VuY0NyeXB0b0tleT86IHN0cmluZztcbiAgICByZWFkb25seSBfc3VidGxlQ3J5cHRvID0gd2luZG93LmNyeXB0by5zdWJ0bGU7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBJQ3J5cHRvT3B0aW9ucykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBrZXkgdXNpbmcgS0RGIHdpdGggc2NyeXB0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIGludHJvZHVjZWQgcGFzc3dvcmQgYnkgdXNlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFzZTY0Rm9ybWF0IGlmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZXR1cm5lZCBpbiBiYXNlNjQgZm9ybWF0XG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBnZW5lcmF0ZWQga2V5XG4gICAgICovXG4gICAgLy9UT0RPIHBhc3Mga2V5TGVuZ3RoIGFzIHBhcmFtZXRlclxuICAgIGFzeW5jIGdlbmVyYXRlS2V5KFxuICAgICAgICBwYXNzd29yZDogc3RyaW5nLFxuICAgICAgICBiYXNlNjRGb3JtYXQ6IGJvb2xlYW5cbiAgICApOiBQcm9taXNlPHN0cmluZyB8IEFycmF5QnVmZmVyPiB7XG4gICAgICAgIGNvbnN0IHNhbHQ6IEFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUZpeGVkU2FsdChwYXNzd29yZCk7XG4gICAgICAgIGNvbnN0IGRlcml2ZWRLZXlMZW5ndGggPSAzMjsgLy8gaW4gYnl0ZXNcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgc2NyeXB0UGJrZGYuc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBkZXJpdmVkS2V5TGVuZ3RoKTsgLy8ga2V5IGlzIGFuIEFycmF5QnVmZmVyXG5cbiAgICAgICAgaWYgKGJhc2U2NEZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEJ1ZmZlclRvQmFzZTY0KGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGZpeGVkIHNhbHQsIGl0IGhhcyB0byBiZSB0aGUgc2FtZSB0byBjaGVjayB0aGUga2V5IGxhdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIHBhc3N3b3JkIGludHJvZHVjZWQgYnkgdXNlclxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbWV0ZXJcbiAgICBhc3luYyBnZW5lcmF0ZUZpeGVkU2FsdChwYXNzd29yZDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGhhc2g6IEFycmF5QnVmZmVyID0gKGF3YWl0IHRoaXMuZ2VuZXJhdGVQYXNzd29yZEhhc2goXG4gICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgIFwiU0hBLTI1NlwiLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKSkgYXMgdW5rbm93biBhcyBBcnJheUJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIGhhc2guc2xpY2UoMTYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGZpeGVkIHNhbHQsIGl0IGhhcyB0byBiZSB0aGUgc2FtZSB0byBjaGVjayB0aGUga2V5IGxhdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIHBhc3N3b3JkIGludHJvZHVjZWQgYnkgdXNlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGdvcml0aG0gdXNlZCB0byBnZW5lcmF0ZSB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFzZTY0Rm9ybWF0IGluZGljYXRlcyBpZiB0aGUgb3V0cHV0IGlzIGluIGJhc2U2NCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIC8vVE9ETzogcGFzcyBhbGdvcml0aG0gYW5kIGlmIHJldHVybiB2YWx1ZSBpbiBiYXNlNjQgb3IgQXJyYXlCdWZmZXJcbiAgICBhc3luYyBnZW5lcmF0ZVBhc3N3b3JkSGFzaChcbiAgICAgICAgcGFzc3dvcmQ6IHN0cmluZyxcbiAgICAgICAgYWxnb3JpdGhtOiBzdHJpbmcsXG4gICAgICAgIGJhc2U2NEZvcm1hdDogYm9vbGVhblxuICAgICk6IFByb21pc2U8c3RyaW5nIHwgQXJyYXlCdWZmZXI+IHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUocGFzc3dvcmQpO1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xuICAgICAgICBpZiAoYmFzZTY0Rm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QnVmZmVyVG9CYXNlNjQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgQ3J5cHRvS2V5IG9iamVjdCB3aXRoIFN1YnRsZUNyeXB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlEYXRhIEtleSBwYXNzZWQgYXMgc3RyaW5nIGVuY29kZWQgd2l0aCBiYXNlNjRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDcnlwdG9LZXkgb2JqZWN0IHN0cmluZ2lmaWVkXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGtleXVzYWdlIGFzIHBhcmFtXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbVxuICAgIC8vVE9ETzogcGFzcyBleHRyYWN0YWJsZSBhcyBwYXJhbVxuICAgIGFzeW5jIGdlbmVyYXRlQ3J5cHRvS2V5KGtleURhdGE6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGxldCBrZXlEYXRhRGVjb2RlZDogc3RyaW5nIHwgVWludDhBcnJheSA9XG4gICAgICAgICAgICB0aGlzLmNvbnZlcnRCYXNlNjRUb0J1ZmZlcihrZXlEYXRhKTtcbiAgICAgICAgbGV0IGNyeXB0b0tleTogQ3J5cHRvS2V5O1xuICAgICAgICBsZXQgYWN0aW9uczogS2V5VXNhZ2VbXSA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCJdO1xuICAgICAgICBpZiAodHlwZW9mIGtleURhdGFEZWNvZGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXlEYXRhRGVjb2RlZCA9IEJ1ZmZlci5mcm9tKGtleURhdGFEZWNvZGVkLCBcInV0Zi04XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqc29uV2ViS2V5OiBzdHJpbmcgPSBcIlwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmltcG9ydEtleShcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgICAgICBrZXlEYXRhRGVjb2RlZCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX29wdGlvbnMuYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRLZXk6IEpzb25XZWJLZXkgPSBhd2FpdCB0aGlzLl9zdWJ0bGVDcnlwdG8uZXhwb3J0S2V5KFxuICAgICAgICAgICAgICAgIFwiandrXCIsXG4gICAgICAgICAgICAgICAgY3J5cHRvS2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAganNvbldlYktleSA9IEpTT04uc3RyaW5naWZ5KGV4cG9ydGVkS2V5KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY3J5cHRvS2V5R2xvYmFsKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgQ3J5cHRvS2V5OiBcIiArIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbldlYktleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNyeXB0IGRhdGEgcGFzc2luZyBjcnlwdG9LZXkgYW5kIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3J5cHRvS2V5SndrXG4gICAgICogQHJldHVybnMge0pTT059IFJldHVybnMgSVYgYW5kIGRhdGEgZW5jcnlwdGVkXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbVxuICAgIC8vVE9ETzogcGFzcyBjcnlwdG9LZXkgYXMgc3RyaW5nIG9yIEFycmF5QnVmZmVyXG4gICAgYXN5bmMgZW5jcnlwdERhdGEoZGF0YTogQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5jb252ZXJ0SndrVG9DcnlwdG9LZXkoXG4gICAgICAgICAgICB0aGlzLl9lbmNDcnlwdG9LZXkgYXMgc3RyaW5nLFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hbGdvcml0aG1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBpdiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKTtcbiAgICAgICAgbGV0IGNpcGhlcnRleHQ6IEFycmF5QnVmZmVyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmVuY3J5cHQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9vcHRpb25zLmFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICAgICAgaXYsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcnlwdG9LZXksXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy9UT0RPIENoZWNrIHRvIHJldHVybiBkYXRhIGFzIEFycmF5QnVmZmVyXG4gICAgICAgICAgICAvL1RPRE8gZXBvY2h0aW1lXG4gICAgICAgICAgICBjb25zdCBiYXNlNjRJViA9IHRoaXMuY29udmVydEJ1ZmZlclRvQmFzZTY0KGl2KTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSB0aGlzLmNvbnZlcnRCdWZmZXJUb0Jhc2U2NChjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICBiYXNlNjRJVixcbiAgICAgICAgICAgICAgICBiYXNlNjREYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdEVuY3J5cHRlZERhdGEoZW5jcnlwdGVkT2JqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBlbmNyeXB0aW5nIGRhdGE6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzcyBKc29uV2ViS2V5IHRvIENyeXB0b0tleSBhbmQgZGVjcnlwdCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJDcnlwdG9LZXkgSnNvbldlYktleSBzdHJpbmdpZmllZFxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGVuY3J5cHRlZERhdGEgRW5jcnlwdGVkIGJpbmFyeSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFJViB1c2VkIHRvIGVuY3J5cHQgZGF0YVxuICAgICAqL1xuICAgIC8vVE9ETzogcGFzcyBhbGdvcml0aG0gYXMgcGFyYW1cbiAgICBhc3luYyBkZWNyeXB0RGF0YShlbmNyeXB0ZWREYXRhOiBBcnJheUJ1ZmZlciwgZGF0YUlWOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5jb252ZXJ0SndrVG9DcnlwdG9LZXkoXG4gICAgICAgICAgICB0aGlzLl9lbmNDcnlwdG9LZXkgYXMgc3RyaW5nLFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hbGdvcml0aG1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXYgPSB0aGlzLmNvbnZlcnRCYXNlNjRUb0J1ZmZlcihkYXRhSVYpIGFzIFVpbnQ4QXJyYXk7XG5cbiAgICAgICAgaWYgKGl2IGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBlbmNyeXB0ZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmRlY3J5cHQoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQUVTLUdDTVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjcnlwdG9LZXksXG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZERhdGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJGYWlsZWQgYXV0aGVudGljYXRpb24uXCI7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRvU3RyaW5nKCkgPT09IFwiRXJyb3I6IENpcGhlciBqb2IgZmFpbGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvcjogV3JvbmcgcGFzc3dvcmQhISFcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjcnlwdGluZyBkYXRhOiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRhdGF0eXBlIGR1cmluZyBJViBhbmQgQ2lwaGVyIHByb2Nlc3NpbmcuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29udmVydEJ1ZmZlclRvQmFzZTY0KGRhdGE6IEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQuZW5jb2RlKGRhdGEsIHRydWUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb252ZXJ0QmFzZTY0VG9CdWZmZXIoZGF0YTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcG9ydCBDcnlwdG9LZXkgaW4gandrIGZvcm1hdFxuICAgICAqIGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGp3ayBKU09OIFdlYiBLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxnb3JpdGhtXG4gICAgICovXG4gICAgYXN5bmMgY29udmVydEp3a1RvQ3J5cHRvS2V5KGp3azogc3RyaW5nLCBhbGdvcml0aG06IHN0cmluZykge1xuICAgICAgICBjb25zdCBqd2tQYXJzZWQ6IEpzb25XZWJLZXkgPSBKU09OLnBhcnNlKGp3ayk7XG4gICAgICAgIGxldCBrZXlEYXRhRGVjb2RlZCA9IHRoaXMuY29udmVydEJhc2U2NFRvQnVmZmVyKGp3a1BhcnNlZC5rISk7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5RGF0YURlY29kZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleURhdGFEZWNvZGVkID0gQnVmZmVyLmZyb20oa2V5RGF0YURlY29kZWQsIFwidXRmLThcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnRsZUNyeXB0by5pbXBvcnRLZXkoXG4gICAgICAgICAgICBcInJhd1wiLFxuICAgICAgICAgICAga2V5RGF0YURlY29kZWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogYWxnb3JpdGhtLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGp3a1BhcnNlZC5leHQhLFxuICAgICAgICAgICAgandrUGFyc2VkLmtleV9vcHMgYXMgS2V5VXNhZ2VbXVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZvcm1hdEVuY3J5cHRlZERhdGEoZW5jcnlwdGVkT2JqZWN0OiBFbmNyeXB0ZWREYXRhKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGl2OiBlbmNyeXB0ZWRPYmplY3QuYmFzZTY0SVYsXG4gICAgICAgICAgICBlbmNyeXB0ZWREYXRhOiBlbmNyeXB0ZWRPYmplY3QuYmFzZTY0RGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG5cbiAgICAvL0dFVFRFUlMgJiBTRVRURVJTXG4gICAgcHVibGljIGdldCBlbmNDcnlwdG9LZXkoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY0NyeXB0b0tleTtcbiAgICB9XG4gICAgcHVibGljIHNldCBlbmNDcnlwdG9LZXkodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9lbmNDcnlwdG9LZXkgPSB2YWx1ZTtcbiAgICB9XG59XG4iXX0=