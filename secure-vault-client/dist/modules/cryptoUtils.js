import * as scryptPbkdf from "scrypt-pbkdf";
import * as base64 from "@juanelas/base64";
export class CryptoUtil {
    constructor(options) {
        this._subtleCrypto = window.crypto.subtle;
        this._options = options;
    }
    /**
     * Generate key using KDF with scrypt
     * @param {string} password introduced password by user
     * @param {boolean} base64Format if true, the key will be returned in base64 format
     * @returns {ArrayBuffer} generated key
     */
    //TODO pass keyLength as parameter
    async generateKey(password, base64Format) {
        const salt = await this.generateFixedSalt(password);
        const derivedKeyLength = 32; // in bytes
        const key = await scryptPbkdf.scrypt(password, salt, derivedKeyLength); // key is an ArrayBuffer
        if (base64Format) {
            return this.convertBufferToBase64(key);
        }
        return key;
    }
    /**
     * Generate fixed salt, it has to be the same to check the key later
     * @param {string} password password introduced by user
     * @returns
     */
    //TODO: pass algorithm as parameter
    async generateFixedSalt(password) {
        const hash = (await this.generatePasswordHash(password, "SHA-256", false));
        return hash.slice(16);
    }
    /**
     * Generate fixed salt, it has to be the same to check the key later
     * @param {string} password password introduced by user
     * @param {string} algorithm used to generate the hash
     * @param {boolean} base64Format indicates if the output is in base64 format
     * @returns
     */
    //TODO: pass algorithm and if return value in base64 or ArrayBuffer
    async generatePasswordHash(password, algorithm, base64Format) {
        const encoder = new TextEncoder();
        const data = encoder.encode(password);
        const hash = await this._subtleCrypto.digest(algorithm, data);
        if (base64Format) {
            return this.convertBufferToBase64(hash);
        }
        return hash;
    }
    /**
     * Generate CryptoKey object with SubtleCrypto
     * @param {string} keyData Key passed as string encoded with base64
     * @returns {string} CryptoKey object stringified
     */
    //TODO: pass keyusage as param
    //TODO: pass algorithm as param
    //TODO: pass extractable as param
    async generateCryptoKey(keyData) {
        let keyDataDecoded = this.convertBase64ToBuffer(keyData);
        let cryptoKey;
        let actions = ["encrypt", "decrypt"];
        if (typeof keyDataDecoded === "string") {
            keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
        }
        let jsonWebKey = "";
        try {
            cryptoKey = await this._subtleCrypto.importKey(this._options.format, keyDataDecoded, {
                name: this._options.algorithm,
            }, true, actions);
            const exportedKey = await this._subtleCrypto.exportKey("jwk", cryptoKey);
            jsonWebKey = JSON.stringify(exportedKey);
            //console.log(cryptoKeyGlobal)
        }
        catch (error) {
            console.error("Error generating CryptoKey: " + error);
        }
        return jsonWebKey;
    }
    /**
     * Encrypt data passing cryptoKey and data
     * @param {string} cryptoKeyJwk
     * @returns {JSON} Returns IV and data encrypted
     */
    //TODO: pass algorithm as param
    //TODO: pass cryptoKey as string or ArrayBuffer
    async encryptData(data) {
        const cryptoKey = await this.convertJwkToCryptoKey(this._encCryptoKey, this._options.algorithm);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        let ciphertext;
        try {
            ciphertext = await this._subtleCrypto.encrypt({
                name: this._options.algorithm,
                iv,
            }, cryptoKey, data);
            //TODO Check to return data as ArrayBuffer
            //TODO epochtime
            const base64IV = this.convertBufferToBase64(iv);
            const base64Data = this.convertBufferToBase64(ciphertext);
            const encryptedObject = {
                base64IV,
                base64Data,
            };
            return this.formatEncryptedData(encryptedObject);
        }
        catch (error) {
            console.error("Error encrypting data: " + error);
        }
    }
    /**
     * Pass JsonWebKey to CryptoKey and decrypt data
     * @param {string} userCryptoKey JsonWebKey stringified
     * @param {ArrayBuffer} encryptedData Encrypted binary data
     * @param {string} dataIV used to encrypt data
     */
    //TODO: pass algorithm as param
    async decryptData(encryptedData, dataIV) {
        const cryptoKey = await this.convertJwkToCryptoKey(this._encCryptoKey, this._options.algorithm);
        const iv = this.convertBase64ToBuffer(dataIV);
        if (iv instanceof Uint8Array && encryptedData instanceof Uint8Array) {
            try {
                return await this._subtleCrypto.decrypt({
                    name: "AES-GCM",
                    iv: iv,
                }, cryptoKey, encryptedData);
            }
            catch (error) {
                let errorMessage = "Failed authentication.";
                if (error instanceof Error) {
                    if (error.toString() === "Error: Cipher job failed") {
                        console.error("Error: Wrong password!!!");
                    }
                    else {
                        console.error("Error decrypting data: " + error);
                    }
                }
                console.log(errorMessage);
            }
        }
        else {
            console.error("Error datatype during IV and Cipher processing.");
        }
    }
    async downloadDataFromUrl(downloadUrl, saltData) {
        const cryptoUtil = this;
        let data = "";
        const res = await fetch(downloadUrl, {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        })
            .then((response) => {
            return response.body;
        })
            .then((rb) => {
            if (rb === null)
                throw new Error("Response body is null");
            const reader = rb.getReader();
            return new ReadableStream({
                start(controller) {
                    // The following function handles each data chunk
                    const push = () => {
                        // "done" is a Boolean and value a "Uint8Array"
                        reader.read().then(async ({ done, value }) => {
                            // If there is no more data to read
                            if (done) {
                                console.log("done", done);
                                controller.close();
                                return;
                            }
                            const decryptedData = await cryptoUtil.decryptData(value, saltData);
                            // Get the data and send it to the browser via the controller
                            controller.enqueue(decryptedData);
                            // Check chunks by logging to the console
                            console.log(done, value);
                            push();
                        });
                    };
                    push();
                },
            });
        })
            .then((stream) => 
        // Respond with our stream
        stream
            .getReader()
            .read()
            .then(({ value }) => {
            data = value;
        }))
            .then((result) => {
            // Do things with result
            console.log(result);
        })
            .catch((e) => console.error(e.message));
        return data;
        // console.log(res);
    }
    async downloadDataFromLocalStorage(saltData) {
        try {
            if (localStorage.getItem("vault_data_type") === null)
                throw Error;
            const decoder = new TextDecoder();
            const encodedType = this.convertBase64ToBuffer(localStorage.getItem("vault_data_type"));
            const vault_type = decoder.decode(encodedType);
            const vault_data = this.convertBase64ToBuffer(localStorage.getItem("vault_data"));
            const decryptedData = await this.decryptData(vault_data, saltData);
            const randomName = this.convertBufferToBase64(crypto.getRandomValues(new Uint8Array(12)));
            //TODO check file extension
            if (decryptedData === undefined)
                throw Error;
            const blob = new Blob([decryptedData], { type: vault_type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = randomName;
            document.body.appendChild(a); // we need to append the element to the dom -> otherwise it will not work in firefox
            a.click();
            a.remove();
        }
        catch (error) {
            console.error("Error downloading data from local storage");
        }
    }
    convertBufferToBase64(data) {
        return base64.encode(data, true, false);
    }
    convertBase64ToBuffer(data) {
        return base64.decode(data);
    }
    /**
     * Import CryptoKey in jwk format
     * format, keyData, algorithm, extractable, keyUsages
     * @param {string} jwk JSON Web Key
     * @param {string} algorithm
     */
    async convertJwkToCryptoKey(jwk, algorithm) {
        const jwkParsed = JSON.parse(jwk);
        let keyDataDecoded = this.convertBase64ToBuffer(jwkParsed.k);
        if (typeof keyDataDecoded === "string") {
            keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
        }
        return this._subtleCrypto.importKey("raw", keyDataDecoded, {
            name: algorithm,
        }, jwkParsed.ext, jwkParsed.key_ops);
    }
    formatEncryptedData(encryptedObject) {
        const data = [];
        data.push({
            iv: encryptedObject.base64IV,
            encryptedData: encryptedObject.base64Data,
        });
        return JSON.stringify(data);
    }
    //GETTERS & SETTERS
    get encCryptoKey() {
        return this._encCryptoKey;
    }
    set encCryptoKey(value) {
        this._encCryptoKey = value;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvVXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbW9kdWxlcy9jcnlwdG9VdGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssV0FBVyxNQUFNLGNBQWMsQ0FBQztBQUU1QyxPQUFPLEtBQUssTUFBTSxNQUFNLGtCQUFrQixDQUFDO0FBUzNDLE1BQU0sT0FBTyxVQUFVO0lBS25CLFlBQVksT0FBdUI7UUFGMUIsa0JBQWEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUcxQyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxrQ0FBa0M7SUFDbEMsS0FBSyxDQUFDLFdBQVcsQ0FDYixRQUFnQixFQUNoQixZQUFxQjtRQUVyQixNQUFNLElBQUksR0FBZ0IsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDakUsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsQ0FBQyxXQUFXO1FBQ3hDLE1BQU0sR0FBRyxHQUFHLE1BQU0sV0FBVyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFFaEcsSUFBSSxZQUFZLEVBQUU7WUFDZCxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxQztRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxtQ0FBbUM7SUFDbkMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLFFBQWdCO1FBQ3BDLE1BQU0sSUFBSSxHQUFnQixDQUFDLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUN0RCxRQUFRLEVBQ1IsU0FBUyxFQUNULEtBQUssQ0FDUixDQUEyQixDQUFDO1FBQzdCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMs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SUFBVyxZQUFZLENBQUMsS0FBeUI7UUFDN0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7SUFDL0IsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc2NyeXB0UGJrZGYgZnJvbSBcInNjcnlwdC1wYmtkZlwiO1xuXG5pbXBvcnQgKiBhcyBiYXNlNjQgZnJvbSBcIkBqdWFuZWxhcy9iYXNlNjRcIjtcblxuaW1wb3J0IHsgSUNyeXB0b09wdGlvbnMgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9pbnRlcmZhY2VzXCI7XG5cbmludGVyZmFjZSBFbmNyeXB0ZWREYXRhIHtcbiAgICBiYXNlNjRJVjogc3RyaW5nO1xuICAgIGJhc2U2NERhdGE6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIENyeXB0b1V0aWwge1xuICAgIHByaXZhdGUgX29wdGlvbnM6IElDcnlwdG9PcHRpb25zO1xuICAgIHByaXZhdGUgX2VuY0NyeXB0b0tleT86IHN0cmluZztcbiAgICByZWFkb25seSBfc3VidGxlQ3J5cHRvID0gd2luZG93LmNyeXB0by5zdWJ0bGU7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBJQ3J5cHRvT3B0aW9ucykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBrZXkgdXNpbmcgS0RGIHdpdGggc2NyeXB0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIGludHJvZHVjZWQgcGFzc3dvcmQgYnkgdXNlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFzZTY0Rm9ybWF0IGlmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZXR1cm5lZCBpbiBiYXNlNjQgZm9ybWF0XG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBnZW5lcmF0ZWQga2V5XG4gICAgICovXG4gICAgLy9UT0RPIHBhc3Mga2V5TGVuZ3RoIGFzIHBhcmFtZXRlclxuICAgIGFzeW5jIGdlbmVyYXRlS2V5KFxuICAgICAgICBwYXNzd29yZDogc3RyaW5nLFxuICAgICAgICBiYXNlNjRGb3JtYXQ6IGJvb2xlYW5cbiAgICApOiBQcm9taXNlPHN0cmluZyB8IEFycmF5QnVmZmVyPiB7XG4gICAgICAgIGNvbnN0IHNhbHQ6IEFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUZpeGVkU2FsdChwYXNzd29yZCk7XG4gICAgICAgIGNvbnN0IGRlcml2ZWRLZXlMZW5ndGggPSAzMjsgLy8gaW4gYnl0ZXNcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgc2NyeXB0UGJrZGYuc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBkZXJpdmVkS2V5TGVuZ3RoKTsgLy8ga2V5IGlzIGFuIEFycmF5QnVmZmVyXG5cbiAgICAgICAgaWYgKGJhc2U2NEZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEJ1ZmZlclRvQmFzZTY0KGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGZpeGVkIHNhbHQsIGl0IGhhcyB0byBiZSB0aGUgc2FtZSB0byBjaGVjayB0aGUga2V5IGxhdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIHBhc3N3b3JkIGludHJvZHVjZWQgYnkgdXNlclxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbWV0ZXJcbiAgICBhc3luYyBnZW5lcmF0ZUZpeGVkU2FsdChwYXNzd29yZDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGhhc2g6IEFycmF5QnVmZmVyID0gKGF3YWl0IHRoaXMuZ2VuZXJhdGVQYXNzd29yZEhhc2goXG4gICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgIFwiU0hBLTI1NlwiLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKSkgYXMgdW5rbm93biBhcyBBcnJheUJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIGhhc2guc2xpY2UoMTYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGZpeGVkIHNhbHQsIGl0IGhhcyB0byBiZSB0aGUgc2FtZSB0byBjaGVjayB0aGUga2V5IGxhdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIHBhc3N3b3JkIGludHJvZHVjZWQgYnkgdXNlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGdvcml0aG0gdXNlZCB0byBnZW5lcmF0ZSB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFzZTY0Rm9ybWF0IGluZGljYXRlcyBpZiB0aGUgb3V0cHV0IGlzIGluIGJhc2U2NCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIC8vVE9ETzogcGFzcyBhbGdvcml0aG0gYW5kIGlmIHJldHVybiB2YWx1ZSBpbiBiYXNlNjQgb3IgQXJyYXlCdWZmZXJcbiAgICBhc3luYyBnZW5lcmF0ZVBhc3N3b3JkSGFzaChcbiAgICAgICAgcGFzc3dvcmQ6IHN0cmluZyxcbiAgICAgICAgYWxnb3JpdGhtOiBzdHJpbmcsXG4gICAgICAgIGJhc2U2NEZvcm1hdDogYm9vbGVhblxuICAgICk6IFByb21pc2U8c3RyaW5nIHwgQXJyYXlCdWZmZXI+IHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUocGFzc3dvcmQpO1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xuICAgICAgICBpZiAoYmFzZTY0Rm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QnVmZmVyVG9CYXNlNjQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgQ3J5cHRvS2V5IG9iamVjdCB3aXRoIFN1YnRsZUNyeXB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlEYXRhIEtleSBwYXNzZWQgYXMgc3RyaW5nIGVuY29kZWQgd2l0aCBiYXNlNjRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDcnlwdG9LZXkgb2JqZWN0IHN0cmluZ2lmaWVkXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGtleXVzYWdlIGFzIHBhcmFtXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbVxuICAgIC8vVE9ETzogcGFzcyBleHRyYWN0YWJsZSBhcyBwYXJhbVxuICAgIGFzeW5jIGdlbmVyYXRlQ3J5cHRvS2V5KGtleURhdGE6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGxldCBrZXlEYXRhRGVjb2RlZDogc3RyaW5nIHwgVWludDhBcnJheSA9XG4gICAgICAgICAgICB0aGlzLmNvbnZlcnRCYXNlNjRUb0J1ZmZlcihrZXlEYXRhKTtcbiAgICAgICAgbGV0IGNyeXB0b0tleTogQ3J5cHRvS2V5O1xuICAgICAgICBsZXQgYWN0aW9uczogS2V5VXNhZ2VbXSA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCJdO1xuICAgICAgICBpZiAodHlwZW9mIGtleURhdGFEZWNvZGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXlEYXRhRGVjb2RlZCA9IEJ1ZmZlci5mcm9tKGtleURhdGFEZWNvZGVkLCBcInV0Zi04XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqc29uV2ViS2V5OiBzdHJpbmcgPSBcIlwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmltcG9ydEtleShcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgICAgICBrZXlEYXRhRGVjb2RlZCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX29wdGlvbnMuYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRLZXk6IEpzb25XZWJLZXkgPSBhd2FpdCB0aGlzLl9zdWJ0bGVDcnlwdG8uZXhwb3J0S2V5KFxuICAgICAgICAgICAgICAgIFwiandrXCIsXG4gICAgICAgICAgICAgICAgY3J5cHRvS2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAganNvbldlYktleSA9IEpTT04uc3RyaW5naWZ5KGV4cG9ydGVkS2V5KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY3J5cHRvS2V5R2xvYmFsKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgQ3J5cHRvS2V5OiBcIiArIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbldlYktleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNyeXB0IGRhdGEgcGFzc2luZyBjcnlwdG9LZXkgYW5kIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3J5cHRvS2V5SndrXG4gICAgICogQHJldHVybnMge0pTT059IFJldHVybnMgSVYgYW5kIGRhdGEgZW5jcnlwdGVkXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbVxuICAgIC8vVE9ETzogcGFzcyBjcnlwdG9LZXkgYXMgc3RyaW5nIG9yIEFycmF5QnVmZmVyXG4gICAgYXN5bmMgZW5jcnlwdERhdGEoZGF0YTogQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5jb252ZXJ0SndrVG9DcnlwdG9LZXkoXG4gICAgICAgICAgICB0aGlzLl9lbmNDcnlwdG9LZXkgYXMgc3RyaW5nLFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hbGdvcml0aG1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBpdiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKTtcbiAgICAgICAgbGV0IGNpcGhlcnRleHQ6IEFycmF5QnVmZmVyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmVuY3J5cHQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9vcHRpb25zLmFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICAgICAgaXYsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcnlwdG9LZXksXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy9UT0RPIENoZWNrIHRvIHJldHVybiBkYXRhIGFzIEFycmF5QnVmZmVyXG4gICAgICAgICAgICAvL1RPRE8gZXBvY2h0aW1lXG4gICAgICAgICAgICBjb25zdCBiYXNlNjRJViA9IHRoaXMuY29udmVydEJ1ZmZlclRvQmFzZTY0KGl2KTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSB0aGlzLmNvbnZlcnRCdWZmZXJUb0Jhc2U2NChjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICBiYXNlNjRJVixcbiAgICAgICAgICAgICAgICBiYXNlNjREYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdEVuY3J5cHRlZERhdGEoZW5jcnlwdGVkT2JqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBlbmNyeXB0aW5nIGRhdGE6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzcyBKc29uV2ViS2V5IHRvIENyeXB0b0tleSBhbmQgZGVjcnlwdCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJDcnlwdG9LZXkgSnNvbldlYktleSBzdHJpbmdpZmllZFxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGVuY3J5cHRlZERhdGEgRW5jcnlwdGVkIGJpbmFyeSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFJViB1c2VkIHRvIGVuY3J5cHQgZGF0YVxuICAgICAqL1xuICAgIC8vVE9ETzogcGFzcyBhbGdvcml0aG0gYXMgcGFyYW1cbiAgICBhc3luYyBkZWNyeXB0RGF0YShlbmNyeXB0ZWREYXRhOiBBcnJheUJ1ZmZlciwgZGF0YUlWOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5jb252ZXJ0SndrVG9DcnlwdG9LZXkoXG4gICAgICAgICAgICB0aGlzLl9lbmNDcnlwdG9LZXkgYXMgc3RyaW5nLFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hbGdvcml0aG1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXYgPSB0aGlzLmNvbnZlcnRCYXNlNjRUb0J1ZmZlcihkYXRhSVYpIGFzIFVpbnQ4QXJyYXk7XG5cbiAgICAgICAgaWYgKGl2IGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBlbmNyeXB0ZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmRlY3J5cHQoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQUVTLUdDTVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjcnlwdG9LZXksXG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZERhdGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJGYWlsZWQgYXV0aGVudGljYXRpb24uXCI7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRvU3RyaW5nKCkgPT09IFwiRXJyb3I6IENpcGhlciBqb2IgZmFpbGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvcjogV3JvbmcgcGFzc3dvcmQhISFcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjcnlwdGluZyBkYXRhOiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRhdGF0eXBlIGR1cmluZyBJViBhbmQgQ2lwaGVyIHByb2Nlc3NpbmcuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZG93bmxvYWREYXRhRnJvbVVybChkb3dubG9hZFVybDogc3RyaW5nLCBzYWx0RGF0YTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNyeXB0b1V0aWwgPSB0aGlzO1xuICAgICAgICBsZXQgZGF0YTogc3RyaW5nID0gXCJcIjtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goZG93bmxvYWRVcmwgYXMgc3RyaW5nLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiOiBcIipcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIGJvZHkgaXMgbnVsbFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSByYi5nZXRSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGhhbmRsZXMgZWFjaCBkYXRhIGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwdXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiZG9uZVwiIGlzIGEgQm9vbGVhbiBhbmQgdmFsdWUgYSBcIlVpbnQ4QXJyYXlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihhc3luYyAoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG1vcmUgZGF0YSB0byByZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRvbmVcIiwgZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNyeXB0b1V0aWwuZGVjcnlwdERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FsdERhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSBhbmQgc2VuZCBpdCB0byB0aGUgYnJvd3NlciB2aWEgdGhlIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRlY3J5cHRlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBjaHVua3MgYnkgbG9nZ2luZyB0byB0aGUgY29uc29sZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkb25lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoc3RyZWFtKSA9PlxuICAgICAgICAgICAgICAgIC8vIFJlc3BvbmQgd2l0aCBvdXIgc3RyZWFtXG4gICAgICAgICAgICAgICAgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgIC5nZXRSZWFkZXIoKVxuICAgICAgICAgICAgICAgICAgICAucmVhZCgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEbyB0aGluZ3Mgd2l0aCByZXN1bHRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gY29uc29sZS5lcnJvcihlLm1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZG93bmxvYWREYXRhRnJvbUxvY2FsU3RvcmFnZShzYWx0RGF0YTogc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ2YXVsdF9kYXRhX3R5cGVcIikgPT09IG51bGwpIHRocm93IEVycm9yO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFR5cGUgPSB0aGlzLmNvbnZlcnRCYXNlNjRUb0J1ZmZlcihcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInZhdWx0X2RhdGFfdHlwZVwiKSBhcyBzdHJpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCB2YXVsdF90eXBlID0gZGVjb2Rlci5kZWNvZGUoZW5jb2RlZFR5cGUgYXMgVWludDhBcnJheSk7XG4gICAgICAgICAgICBjb25zdCB2YXVsdF9kYXRhID0gdGhpcy5jb252ZXJ0QmFzZTY0VG9CdWZmZXIoXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ2YXVsdF9kYXRhXCIpIGFzIHN0cmluZ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IGF3YWl0IHRoaXMuZGVjcnlwdERhdGEoXG4gICAgICAgICAgICAgICAgdmF1bHRfZGF0YSBhcyBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBzYWx0RGF0YVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgcmFuZG9tTmFtZSA9IHRoaXMuY29udmVydEJ1ZmZlclRvQmFzZTY0KFxuICAgICAgICAgICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vVE9ETyBjaGVjayBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGRlY3J5cHRlZERhdGEgPT09IHVuZGVmaW5lZCkgdGhyb3cgRXJyb3I7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2RlY3J5cHRlZERhdGFdLCB7IHR5cGU6IHZhdWx0X3R5cGUgfSk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgICAgICAgYS5kb3dubG9hZCA9IHJhbmRvbU5hbWU7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpOyAvLyB3ZSBuZWVkIHRvIGFwcGVuZCB0aGUgZWxlbWVudCB0byB0aGUgZG9tIC0+IG90aGVyd2lzZSBpdCB3aWxsIG5vdCB3b3JrIGluIGZpcmVmb3hcbiAgICAgICAgICAgIGEuY2xpY2soKTtcbiAgICAgICAgICAgIGEucmVtb3ZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZG93bmxvYWRpbmcgZGF0YSBmcm9tIGxvY2FsIHN0b3JhZ2VcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb252ZXJ0QnVmZmVyVG9CYXNlNjQoZGF0YTogQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoZGF0YSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnZlcnRCYXNlNjRUb0J1ZmZlcihkYXRhOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5kZWNvZGUoZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wb3J0IENyeXB0b0tleSBpbiBqd2sgZm9ybWF0XG4gICAgICogZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gandrIEpTT04gV2ViIEtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGdvcml0aG1cbiAgICAgKi9cbiAgICBhc3luYyBjb252ZXJ0SndrVG9DcnlwdG9LZXkoandrOiBzdHJpbmcsIGFsZ29yaXRobTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGp3a1BhcnNlZDogSnNvbldlYktleSA9IEpTT04ucGFyc2UoandrKTtcbiAgICAgICAgbGV0IGtleURhdGFEZWNvZGVkID0gdGhpcy5jb252ZXJ0QmFzZTY0VG9CdWZmZXIoandrUGFyc2VkLmshKTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlEYXRhRGVjb2RlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5RGF0YURlY29kZWQgPSBCdWZmZXIuZnJvbShrZXlEYXRhRGVjb2RlZCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3VidGxlQ3J5cHRvLmltcG9ydEtleShcbiAgICAgICAgICAgIFwicmF3XCIsXG4gICAgICAgICAgICBrZXlEYXRhRGVjb2RlZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhbGdvcml0aG0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgandrUGFyc2VkLmV4dCEsXG4gICAgICAgICAgICBqd2tQYXJzZWQua2V5X29wcyBhcyBLZXlVc2FnZVtdXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZm9ybWF0RW5jcnlwdGVkRGF0YShlbmNyeXB0ZWRPYmplY3Q6IEVuY3J5cHRlZERhdGEpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgaXY6IGVuY3J5cHRlZE9iamVjdC5iYXNlNjRJVixcbiAgICAgICAgICAgIGVuY3J5cHRlZERhdGE6IGVuY3J5cHRlZE9iamVjdC5iYXNlNjREYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cblxuICAgIC8vR0VUVEVSUyAmIFNFVFRFUlNcbiAgICBwdWJsaWMgZ2V0IGVuY0NyeXB0b0tleSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jQ3J5cHRvS2V5O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGVuY0NyeXB0b0tleSh2YWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2VuY0NyeXB0b0tleSA9IHZhbHVlO1xuICAgIH1cbn1cbiJdfQ==