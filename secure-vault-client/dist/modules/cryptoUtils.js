import * as scryptPbkdf from "scrypt-pbkdf";
import * as base64 from "@juanelas/base64";
export class CryptoUtil {
    constructor(options) {
        this._subtleCrypto = window.crypto.subtle;
        this._options = options;
    }
    /**
     * Generate key using KDF with scrypt
     * @param {string} password introduced password by user
     * @param {boolean} base64Format if true, the key will be returned in base64 format
     * @returns {ArrayBuffer} generated key
     */
    //TODO pass keyLength as parameter
    async generateKey(password, base64Format) {
        const salt = await this.generateFixedSalt(password);
        const derivedKeyLength = 32; // in bytes
        const key = await scryptPbkdf.scrypt(password, salt, derivedKeyLength); // key is an ArrayBuffer
        if (base64Format) {
            return this.convertBufferToBase64(key);
        }
        return key;
    }
    /**
     * Generate fixed salt, it has to be the same to check the key later
     * @param {string} password password introduced by user
     * @returns
     */
    //TODO: pass algorithm as parameter
    async generateFixedSalt(password) {
        const hash = (await this.generatePasswordHash(password, "SHA-256", false));
        return hash.slice(16);
    }
    /**
     * Generate fixed salt, it has to be the same to check the key later
     * @param {string} password password introduced by user
     * @param {string} algorithm used to generate the hash
     * @param {boolean} base64Format indicates if the output is in base64 format
     * @returns
     */
    //TODO: pass algorithm and if return value in base64 or ArrayBuffer
    async generatePasswordHash(password, algorithm, base64Format) {
        const encoder = new TextEncoder();
        const data = encoder.encode(password);
        const hash = await this._subtleCrypto.digest(algorithm, data);
        if (base64Format) {
            return this.convertBufferToBase64(hash);
        }
        return hash;
    }
    /**
     * Generate CryptoKey object with SubtleCrypto
     * @param {string} keyData Key passed as string encoded with base64
     * @returns {string} CryptoKey object stringified
     */
    //TODO: pass keyusage as param
    //TODO: pass algorithm as param
    //TODO: pass extractable as param
    async generateCryptoKey(keyData) {
        let keyDataDecoded = this.convertBase64ToBuffer(keyData);
        let cryptoKey;
        let actions = ["encrypt", "decrypt"];
        if (typeof keyDataDecoded === "string") {
            keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
        }
        let jsonWebKey = "";
        try {
            cryptoKey = await this._subtleCrypto.importKey(this._options.format, keyDataDecoded, {
                name: this._options.algorithm,
            }, true, actions);
            const exportedKey = await this._subtleCrypto.exportKey("jwk", cryptoKey);
            jsonWebKey = JSON.stringify(exportedKey);
            //console.log(cryptoKeyGlobal)
        }
        catch (error) {
            console.error("Error generating CryptoKey: " + error);
        }
        return jsonWebKey;
    }
    /**
     * Encrypt data passing cryptoKey and data
     * @param {string} cryptoKeyJwk
     * @returns {JSON} Returns IV and data encrypted
     */
    //TODO: pass algorithm as param
    //TODO: pass cryptoKey as string or ArrayBuffer
    async encryptData(data) {
        const cryptoKey = await this.convertJwkToCryptoKey(this._encCryptoKey, this._options.algorithm);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        let ciphertext;
        try {
            ciphertext = await this._subtleCrypto.encrypt({
                name: this._options.algorithm,
                iv,
            }, cryptoKey, data);
            //TODO Check to return data as ArrayBuffer
            //TODO epochtime
            const base64IV = this.convertBufferToBase64(iv);
            const base64Data = this.convertBufferToBase64(ciphertext);
            const encryptedObject = {
                base64IV,
                base64Data,
            };
            return this.formatEncryptedData(encryptedObject);
        }
        catch (error) {
            console.error("Error encrypting data: " + error);
        }
    }
    /**
     * Pass JsonWebKey to CryptoKey and decrypt data
     * @param {string} userCryptoKey JsonWebKey stringified
     * @param {ArrayBuffer} encryptedData Encrypted binary data
     * @param {string} dataIV used to encrypt data
     */
    //TODO: pass algorithm as param
    async decryptData(encryptedData, dataIV) {
        const cryptoKey = await this.convertJwkToCryptoKey(this._encCryptoKey, this._options.algorithm);
        const iv = this.convertBase64ToBuffer(dataIV);
        if (iv instanceof Uint8Array && encryptedData instanceof Uint8Array) {
            try {
                return await this._subtleCrypto.decrypt({
                    name: "AES-GCM",
                    iv: iv,
                }, cryptoKey, encryptedData);
            }
            catch (error) {
                debugger;
                let errorMessage = "Failed authentication.";
                if (error instanceof Error) {
                    if (error.toString() === "Error: Cipher job failed") {
                        console.error("Error: Wrong password!!!");
                    }
                    else {
                        console.error("Error decrypting data: " + error);
                    }
                }
                console.log(errorMessage);
            }
        }
        else {
            console.error("Error datatype during IV and Cipher processing.");
        }
    }
    convertBufferToBase64(data) {
        return base64.encode(data, true, false);
    }
    convertBase64ToBuffer(data) {
        return base64.decode(data);
    }
    /**
     * Import CryptoKey in jwk format
     * format, keyData, algorithm, extractable, keyUsages
     * @param {string} jwk JSON Web Key
     * @param {string} algorithm
     */
    async convertJwkToCryptoKey(jwk, algorithm) {
        const jwkParsed = JSON.parse(jwk);
        let keyDataDecoded = this.convertBase64ToBuffer(jwkParsed.k);
        if (typeof keyDataDecoded === "string") {
            keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
        }
        return this._subtleCrypto.importKey("raw", keyDataDecoded, {
            name: algorithm,
        }, jwkParsed.ext, jwkParsed.key_ops);
    }
    formatEncryptedData(encryptedObject) {
        const data = [];
        data.push({
            iv: encryptedObject.base64IV,
            encryptedData: encryptedObject.base64Data,
        });
        return JSON.stringify(data);
    }
    //GETTERS & SETTERS
    get encCryptoKey() {
        return this._encCryptoKey;
    }
    set encCryptoKey(value) {
        this._encCryptoKey = value;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvVXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbW9kdWxlcy9jcnlwdG9VdGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssV0FBVyxNQUFNLGNBQWMsQ0FBQztBQUM1QyxPQUFPLEtBQUssTUFBTSxNQUFNLGtCQUFrQixDQUFDO0FBUzNDLE1BQU0sT0FBTyxVQUFVO0lBS25CLFlBQVksT0FBdUI7UUFGMUIsa0JBQWEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUcxQyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxrQ0FBa0M7SUFDbEMsS0FBSyxDQUFDLFdBQVcsQ0FDYixRQUFnQixFQUNoQixZQUFxQjtRQUVyQixNQUFNLElBQUksR0FBZ0IsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDakUsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsQ0FBQyxXQUFXO1FBQ3hDLE1BQU0sR0FBRyxHQUFHLE1BQU0sV0FBVyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFFaEcsSUFBSSxZQUFZLEVBQUU7WUFDZCxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxQztRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxtQ0FBbUM7SUFDbkMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLFFBQWdCO1FBQ3BDLE1BQU0sSUFBSSxHQUFnQixDQUFDLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUN0RCxRQUFRLEVBQ1IsU0FBUyxFQUNULEtBQUssQ0FDUixDQUEyQixDQUFDO1FBQzdCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMs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Q25CLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUM5QixDQUFDO0lBQ0QsSUFBVyxZQUFZLENBQUMsS0FBeUI7UUFDN0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7SUFDL0IsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc2NyeXB0UGJrZGYgZnJvbSBcInNjcnlwdC1wYmtkZlwiO1xuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gXCJAanVhbmVsYXMvYmFzZTY0XCI7XG5cbmltcG9ydCB7IElDcnlwdG9PcHRpb25zIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvaW50ZXJmYWNlc1wiO1xuXG5pbnRlcmZhY2UgRW5jcnlwdGVkRGF0YSB7XG4gICAgYmFzZTY0SVY6IHN0cmluZztcbiAgICBiYXNlNjREYXRhOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBDcnlwdG9VdGlsIHtcbiAgICBwcml2YXRlIF9vcHRpb25zOiBJQ3J5cHRvT3B0aW9ucztcbiAgICBwcml2YXRlIF9lbmNDcnlwdG9LZXk/OiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgX3N1YnRsZUNyeXB0byA9IHdpbmRvdy5jcnlwdG8uc3VidGxlO1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogSUNyeXB0b09wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUga2V5IHVzaW5nIEtERiB3aXRoIHNjcnlwdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBpbnRyb2R1Y2VkIHBhc3N3b3JkIGJ5IHVzZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJhc2U2NEZvcm1hdCBpZiB0cnVlLCB0aGUga2V5IHdpbGwgYmUgcmV0dXJuZWQgaW4gYmFzZTY0IGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gZ2VuZXJhdGVkIGtleVxuICAgICAqL1xuICAgIC8vVE9ETyBwYXNzIGtleUxlbmd0aCBhcyBwYXJhbWV0ZXJcbiAgICBhc3luYyBnZW5lcmF0ZUtleShcbiAgICAgICAgcGFzc3dvcmQ6IHN0cmluZyxcbiAgICAgICAgYmFzZTY0Rm9ybWF0OiBib29sZWFuXG4gICAgKTogUHJvbWlzZTxzdHJpbmcgfCBBcnJheUJ1ZmZlcj4ge1xuICAgICAgICBjb25zdCBzYWx0OiBBcnJheUJ1ZmZlciA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVGaXhlZFNhbHQocGFzc3dvcmQpO1xuICAgICAgICBjb25zdCBkZXJpdmVkS2V5TGVuZ3RoID0gMzI7IC8vIGluIGJ5dGVzXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHNjcnlwdFBia2RmLnNjcnlwdChwYXNzd29yZCwgc2FsdCwgZGVyaXZlZEtleUxlbmd0aCk7IC8vIGtleSBpcyBhbiBBcnJheUJ1ZmZlclxuXG4gICAgICAgIGlmIChiYXNlNjRGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRCdWZmZXJUb0Jhc2U2NChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBmaXhlZCBzYWx0LCBpdCBoYXMgdG8gYmUgdGhlIHNhbWUgdG8gY2hlY2sgdGhlIGtleSBsYXRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBwYXNzd29yZCBpbnRyb2R1Y2VkIGJ5IHVzZXJcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIC8vVE9ETzogcGFzcyBhbGdvcml0aG0gYXMgcGFyYW1ldGVyXG4gICAgYXN5bmMgZ2VuZXJhdGVGaXhlZFNhbHQocGFzc3dvcmQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBoYXNoOiBBcnJheUJ1ZmZlciA9IChhd2FpdCB0aGlzLmdlbmVyYXRlUGFzc3dvcmRIYXNoKFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBcIlNIQS0yNTZcIixcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICkpIGFzIHVua25vd24gYXMgQXJyYXlCdWZmZXI7XG4gICAgICAgIHJldHVybiBoYXNoLnNsaWNlKDE2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBmaXhlZCBzYWx0LCBpdCBoYXMgdG8gYmUgdGhlIHNhbWUgdG8gY2hlY2sgdGhlIGtleSBsYXRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBwYXNzd29yZCBpbnRyb2R1Y2VkIGJ5IHVzZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxnb3JpdGhtIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJhc2U2NEZvcm1hdCBpbmRpY2F0ZXMgaWYgdGhlIG91dHB1dCBpcyBpbiBiYXNlNjQgZm9ybWF0XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICAvL1RPRE86IHBhc3MgYWxnb3JpdGhtIGFuZCBpZiByZXR1cm4gdmFsdWUgaW4gYmFzZTY0IG9yIEFycmF5QnVmZmVyXG4gICAgYXN5bmMgZ2VuZXJhdGVQYXNzd29yZEhhc2goXG4gICAgICAgIHBhc3N3b3JkOiBzdHJpbmcsXG4gICAgICAgIGFsZ29yaXRobTogc3RyaW5nLFxuICAgICAgICBiYXNlNjRGb3JtYXQ6IGJvb2xlYW5cbiAgICApOiBQcm9taXNlPHN0cmluZyB8IEFycmF5QnVmZmVyPiB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKHBhc3N3b3JkKTtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuX3N1YnRsZUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcbiAgICAgICAgaWYgKGJhc2U2NEZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEJ1ZmZlclRvQmFzZTY0KGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIENyeXB0b0tleSBvYmplY3Qgd2l0aCBTdWJ0bGVDcnlwdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5RGF0YSBLZXkgcGFzc2VkIGFzIHN0cmluZyBlbmNvZGVkIHdpdGggYmFzZTY0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gQ3J5cHRvS2V5IG9iamVjdCBzdHJpbmdpZmllZFxuICAgICAqL1xuICAgIC8vVE9ETzogcGFzcyBrZXl1c2FnZSBhcyBwYXJhbVxuICAgIC8vVE9ETzogcGFzcyBhbGdvcml0aG0gYXMgcGFyYW1cbiAgICAvL1RPRE86IHBhc3MgZXh0cmFjdGFibGUgYXMgcGFyYW1cbiAgICBhc3luYyBnZW5lcmF0ZUNyeXB0b0tleShrZXlEYXRhOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBsZXQga2V5RGF0YURlY29kZWQ6IHN0cmluZyB8IFVpbnQ4QXJyYXkgPVxuICAgICAgICAgICAgdGhpcy5jb252ZXJ0QmFzZTY0VG9CdWZmZXIoa2V5RGF0YSk7XG4gICAgICAgIGxldCBjcnlwdG9LZXk6IENyeXB0b0tleTtcbiAgICAgICAgbGV0IGFjdGlvbnM6IEtleVVzYWdlW10gPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlEYXRhRGVjb2RlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5RGF0YURlY29kZWQgPSBCdWZmZXIuZnJvbShrZXlEYXRhRGVjb2RlZCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQganNvbldlYktleTogc3RyaW5nID0gXCJcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNyeXB0b0tleSA9IGF3YWl0IHRoaXMuX3N1YnRsZUNyeXB0by5pbXBvcnRLZXkoXG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQsXG4gICAgICAgICAgICAgICAga2V5RGF0YURlY29kZWQsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9vcHRpb25zLmFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgYWN0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkS2V5Okpzb25XZWJLZXkgPSBhd2FpdCB0aGlzLl9zdWJ0bGVDcnlwdG8uZXhwb3J0S2V5KFxuICAgICAgICAgICAgICAgIFwiandrXCIsXG4gICAgICAgICAgICAgICAgY3J5cHRvS2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAganNvbldlYktleSA9IEpTT04uc3RyaW5naWZ5KGV4cG9ydGVkS2V5KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY3J5cHRvS2V5R2xvYmFsKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgQ3J5cHRvS2V5OiBcIiArIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbldlYktleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNyeXB0IGRhdGEgcGFzc2luZyBjcnlwdG9LZXkgYW5kIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3J5cHRvS2V5SndrXG4gICAgICogQHJldHVybnMge0pTT059IFJldHVybnMgSVYgYW5kIGRhdGEgZW5jcnlwdGVkXG4gICAgICovXG4gICAgLy9UT0RPOiBwYXNzIGFsZ29yaXRobSBhcyBwYXJhbVxuICAgIC8vVE9ETzogcGFzcyBjcnlwdG9LZXkgYXMgc3RyaW5nIG9yIEFycmF5QnVmZmVyXG4gICAgYXN5bmMgZW5jcnlwdERhdGEoZGF0YTogQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgdGhpcy5jb252ZXJ0SndrVG9DcnlwdG9LZXkoXG4gICAgICAgICAgICB0aGlzLl9lbmNDcnlwdG9LZXkgYXMgc3RyaW5nLFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hbGdvcml0aG1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBpdiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKTtcbiAgICAgICAgbGV0IGNpcGhlcnRleHQ6IEFycmF5QnVmZmVyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gYXdhaXQgdGhpcy5fc3VidGxlQ3J5cHRvLmVuY3J5cHQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9vcHRpb25zLmFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICAgICAgaXYsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcnlwdG9LZXksXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy9UT0RPIENoZWNrIHRvIHJldHVybiBkYXRhIGFzIEFycmF5QnVmZmVyXG4gICAgICAgICAgICAvL1RPRE8gZXBvY2h0aW1lXG4gICAgICAgICAgICBjb25zdCBiYXNlNjRJViA9IHRoaXMuY29udmVydEJ1ZmZlclRvQmFzZTY0KGl2KTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSB0aGlzLmNvbnZlcnRCdWZmZXJUb0Jhc2U2NChjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICBiYXNlNjRJVixcbiAgICAgICAgICAgICAgICBiYXNlNjREYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdEVuY3J5cHRlZERhdGEoZW5jcnlwdGVkT2JqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBlbmNyeXB0aW5nIGRhdGE6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzcyBKc29uV2ViS2V5IHRvIENyeXB0b0tleSBhbmQgZGVjcnlwdCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJDcnlwdG9LZXkgSnNvbldlYktleSBzdHJpbmdpZmllZFxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGVuY3J5cHRlZERhdGEgRW5jcnlwdGVkIGJpbmFyeSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFJViB1c2VkIHRvIGVuY3J5cHQgZGF0YVxuICAgICAqL1xuICAgIC8vVE9ETzogcGFzcyBhbGdvcml0aG0gYXMgcGFyYW1cbiAgICBhc3luYyBkZWNyeXB0RGF0YShcbiAgICAgICAgZW5jcnlwdGVkRGF0YTogQXJyYXlCdWZmZXIsXG4gICAgICAgIGRhdGFJVjogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHRoaXMuY29udmVydEp3a1RvQ3J5cHRvS2V5KFxuICAgICAgICAgICAgdGhpcy5fZW5jQ3J5cHRvS2V5IGFzIHN0cmluZyxcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuYWxnb3JpdGhtXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGl2ID0gdGhpcy5jb252ZXJ0QmFzZTY0VG9CdWZmZXIoZGF0YUlWKSBhcyBVaW50OEFycmF5O1xuXG4gICAgICAgIGlmIChpdiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgZW5jcnlwdGVkRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3N1YnRsZUNyeXB0by5kZWNyeXB0KFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkFFUy1HQ01cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGl2OiBpdixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY3J5cHRvS2V5LFxuICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ZWREYXRhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiRmFpbGVkIGF1dGhlbnRpY2F0aW9uLlwiO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50b1N0cmluZygpID09PSBcIkVycm9yOiBDaXBoZXIgam9iIGZhaWxlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6IFdyb25nIHBhc3N3b3JkISEhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlY3J5cHRpbmcgZGF0YTogXCIgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkYXRhdHlwZSBkdXJpbmcgSVYgYW5kIENpcGhlciBwcm9jZXNzaW5nLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnZlcnRCdWZmZXJUb0Jhc2U2NChkYXRhOiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gYmFzZTY0LmVuY29kZShkYXRhLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgY29udmVydEJhc2U2NFRvQnVmZmVyKGRhdGE6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgQ3J5cHRvS2V5IGluIGp3ayBmb3JtYXRcbiAgICAgKiBmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqd2sgSlNPTiBXZWIgS2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsZ29yaXRobVxuICAgICAqL1xuICAgIGFzeW5jIGNvbnZlcnRKd2tUb0NyeXB0b0tleShqd2s6IHN0cmluZywgYWxnb3JpdGhtOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgandrUGFyc2VkOiBKc29uV2ViS2V5ID0gSlNPTi5wYXJzZShqd2spO1xuICAgICAgICBsZXQga2V5RGF0YURlY29kZWQgPSB0aGlzLmNvbnZlcnRCYXNlNjRUb0J1ZmZlcihqd2tQYXJzZWQuayEpO1xuICAgICAgICBpZiAodHlwZW9mIGtleURhdGFEZWNvZGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXlEYXRhRGVjb2RlZCA9IEJ1ZmZlci5mcm9tKGtleURhdGFEZWNvZGVkLCBcInV0Zi04XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFxuICAgICAgICAgICAgXCJyYXdcIixcbiAgICAgICAgICAgIGtleURhdGFEZWNvZGVkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IGFsZ29yaXRobSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBqd2tQYXJzZWQuZXh0ISxcbiAgICAgICAgICAgIGp3a1BhcnNlZC5rZXlfb3BzIGFzIEtleVVzYWdlW11cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3JtYXRFbmNyeXB0ZWREYXRhKGVuY3J5cHRlZE9iamVjdDogRW5jcnlwdGVkRGF0YSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICBpdjogZW5jcnlwdGVkT2JqZWN0LmJhc2U2NElWLFxuICAgICAgICAgICAgZW5jcnlwdGVkRGF0YTogZW5jcnlwdGVkT2JqZWN0LmJhc2U2NERhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuXG4gICAgLy9HRVRURVJTICYgU0VUVEVSU1xuICAgIHB1YmxpYyBnZXQgZW5jQ3J5cHRvS2V5KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNDcnlwdG9LZXk7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgZW5jQ3J5cHRvS2V5KHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fZW5jQ3J5cHRvS2V5ID0gdmFsdWU7XG4gICAgfVxufVxuIl19