import * as scryptPbkdf from 'scrypt-pbkdf';

import * as base64 from '@juanelas/base64';

//SUBTLE CRYPTO CONFIGURATION
//TODO save in ENV variables
const format = "raw";
const hashAlgUsed = "AES-GCM";
const subtleCrypto = window.crypto.subtle;
let cryptoKeyGlobal: string;

interface EncryptedData {
    base64IV: string;
    base64Data: string;
}

/**
 * Generate key using KDF with scrypt
 * @param {string} password introduced password by user
 * @param {string} salt salt generated by server (null when sign up and filled when login)
 */
export const generateKey = async (password: string, iv: string | null) => {

    //TODO pass hash as parameter
    const hashPwd = await generatePasswordHash(password);
    const salt: Uint8Array =
        iv == null
            ? crypto.getRandomValues(new Uint8Array(16))
            : (convertBase64ToBuffer(iv) as Uint8Array);
    const derivedKeyLength = 32; // in bytes
    const key = await scryptPbkdf.scrypt(hashPwd, salt, derivedKeyLength); // key is an ArrayBuffer
    // console.log(key);console.log(convertBufferToBase64(key))

    const base64Salt = convertBufferToBase64(salt);
    const base64Pwd = convertBufferToBase64(key);

    //TODO Check if it is needed to use a salt in the client side and in the server side
    //TODO change the way we store this information like and object and do it separately
    const encryptedObject = {
        base64Salt,
        base64Pwd,
    };

    console.log(JSON.stringify(encryptedObject));
    return encryptedObject;
};

/**
 * Generate fixed salt, it has to be the same to check the key later
 * @param {string} password password introduced by user
 * @returns
 */
const generatePasswordHash = async (password: string): Promise<ArrayBuffer> => {
    const encoder = new TextEncoder();
    const data = encoder.encode(password);
    //console.log(hash)
    return subtleCrypto.digest("SHA-256", data);
};

/**
 * Generate CryptoKey object with SubtleCrypto
 * @param {string} keyData Key passed as string encoded with base64
 * @returns {string} CryptoKey object stringified
 */
export const generateCryptoKey = async (keyData: string) => {
    let keyDataDecoded: string | Uint8Array = convertBase64ToBuffer(keyData);
    let cryptoKey: CryptoKey;
    let actions: KeyUsage[] = ["encrypt", "decrypt"];
    if (typeof keyDataDecoded === "string") {
        keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
    }
    try {
        cryptoKey = await subtleCrypto.importKey(
            format,
            keyDataDecoded,
            {
                name: hashAlgUsed,
            },
            true,
            actions
        );
        const exportedKey = await subtleCrypto.exportKey("jwk", cryptoKey);
        cryptoKeyGlobal = JSON.stringify(exportedKey);
        //console.log(cryptoKeyGlobal)
    } catch (error) {
        console.log("Error generating CryptoKey: " + error);
    }

    return cryptoKeyGlobal;
};

/**
 * Encrypt data passing cryptoKey and data
 * @param {string} cryptoKeyJwk
 * @returns {JSON} Returns IV and data encrypted
 */
export const encryptData = async (cryptoKeyJwk: string, data: ArrayBuffer) => {
    const cryptoKey = await convertJwkToCryptoKey(cryptoKeyJwk, hashAlgUsed);

    const iv = crypto.getRandomValues(new Uint8Array(12));
    let ciphertext: ArrayBuffer;

    try {
        ciphertext = await subtleCrypto.encrypt(
            {
                name: hashAlgUsed,
                iv,
            },
            cryptoKey,
            data
        );
        
        //TODO Check to return data as ArrayBuffer 
        const base64IV = convertBufferToBase64(iv);
        const base64Data = convertBufferToBase64(ciphertext);
        const encryptedObject = {
            base64IV,
            base64Data,
        };
        return formatEncryptedData(encryptedObject);
    } catch (error) {
        console.log("Error encrypting data: " + error);
    }

};

/**
 * Pass JsonWebKey to CryptoKey and decrypt data
 * @param {string} userCryptoKey JsonWebKey stringified
 * @param {ArrayBuffer} encryptedData Encrypted binary data
 * @param {string} dataIV used to encrypt data
 */
export const decryptData = async (userCryptoKey: string, encryptedData: ArrayBuffer, dataIV: string) => {

    const cryptoKey = await convertJwkToCryptoKey(userCryptoKey, hashAlgUsed);
    const iv = convertBase64ToBuffer(dataIV) as Uint8Array;

    if (iv instanceof Uint8Array && encryptedData instanceof Uint8Array) {
        try {
            return await subtleCrypto.decrypt(
                {
                    name: "AES-GCM",
                    iv: iv,
                },
                cryptoKey,
                encryptedData
            );
        } catch (error) {
            debugger;
            let errorMessage = "Failed authentication.";
            if (error instanceof Error) {
                if (error.toString() === "Error: Cipher job failed") {
                    console.log("Error: Wrong password!!!");
                } else {
                    console.log("Error decrypting data: " + error);
                }
            }
            console.log(errorMessage);
        }
    } else {
        console.log("Error datatype during IV and Cipher processing.");
    }
};

export const convertBufferToBase64 = (data: ArrayBuffer) => {
    return base64.encode(data, true, false);
};

export const convertBase64ToBuffer = (data: string) => {
    return base64.decode(data);
};

/**
 * Import CryptoKey in jwk format
 * format, keyData, algorithm, extractable, keyUsages
 * @param {string} jwk JSON Web Key
 * @param {string} algorithm
 */
const convertJwkToCryptoKey = async (jwk: string, algorithm: string) => {
    const jwkParsed: JsonWebKey = JSON.parse(jwk);
    let keyDataDecoded = convertBase64ToBuffer(jwkParsed.k!);
    if (typeof keyDataDecoded === "string") {
        keyDataDecoded = Buffer.from(keyDataDecoded, "utf-8");
    }
    return subtleCrypto.importKey(
        "raw",
        keyDataDecoded,
        {
            name: algorithm,
        },
        jwkParsed.ext!,
        jwkParsed.key_ops as KeyUsage[]
    );
};

export const formatEncryptedData = (encryptedObject: EncryptedData) => {
    const data = [];
    data.push({
        iv: encryptedObject.base64IV,
        encryptedData: encryptedObject.base64Data,
    });
    return JSON.stringify(data);
};
